Двусвязный список
===

* совокупность узлов, состоящих из двух частей: **значения** и **информации о предыдущем и о следующем элементах списка**
* только **последовательный доступ** к элементам
* можно передвигаться **в обе стороны**

![](https://pp.userapi.com/c637819/v637819965/611a4/eWIrMx281Vk.jpg)

Особенности
---

* элементы списка могут храниться не последовательно, а **в разных участках памяти**
* для связи текущего элемента со следующим хранится **указатель на следующий элемент**
* для связи текущего элемента с предыдущим хранится **указатель на предыдущий элемент**
* обход списка **в любом направлении**
* позволяет эффективно **вставлять** элементы в произвольную позицию списка и **удалять** элементы из произвольной позиции

Основные операции
---

* вставить элемент в список (**insert**)
* удалить элемент из списка (**erase**)
* добавить элемент в конец списка (**push_back**)
* удалить элемент из конца списка (**pop_back**)
* добавить элемент в начало списка (**push_front**)
* удалить элемент из начала списка (**pop_front**)
* узнать количество элементов (**size**)
* проверить на пустоту (**empty**)

Реализация: узлы
---

* узел представляет собой **структуру**
* узел содержит **поле с данными** и **указатели**:
  * **на следующий узел**
  * **на предыдущий узел**

```cpp
template <typename T>
struct node {
  T data;
  node* next;
  node* previous;
};
```

Объявление класса
---

* создается класс для реализации списка
* в классе дополнительно создаются поля-указатели на голову и хвост списка (**head** и **tail**)

```cpp
template <typename T>
struct node { ... };

template <typename T>
class MyList {
  node* head;
  node* tail;
};
```

Голова и хвост списка
---

* голова всегда **указывает на первый элемент** в списке
* хвост всегда **указывает на последний элементв** списке
* если в списке нет ни одного элемента, значения головы и хвоста устанавливаются в **NULL** (или **nullptr**)

![](https://pp.userapi.com/c637819/v637819965/611b5/eQT1FOfOA0k.jpg)

Инициализация
---

* в начале работы список пуст
* указатели на хвост и на голову ни на что не указывают

```cpp
template <typename T>
MyList <T>::MyList() : head(nullptr), tail(nullptr) { }
```

Создание первого узла
---

* выделяется память под новый узел
* значение в новом узле устанавливается равным переданному значению
* оба указателя в узле устанавливаются **в nullptr**
* `head` и `tail` указывают на этот новый элемент

![](https://pp.userapi.com/c637819/v637819965/611bc/FyrGQ16G8EI.jpg)

Обход списка
---

* обходить список можно с начала или с конца
* обход организуется в цикле или рекурсивно
* создается **указатель `node* tmp`**, значение которого устанавливается в **head** (указатель на начало списка)
* данные можно получить через **tmp->data**
* значение указателя tmp меняется на **tmp->next** (переход к следующему узлу)
* цикл работает до тех пор, пока указатель **tmp** не равен **NULL** (или **nullptr**)

Обход списка (пример)
---

```cpp
node<T>* tmp = head;
while (tmp != nullptr) {
  std::cout << tmp->data << std::endl;
  tmp = tmp->next;
}
```

![](https://pp.userapi.com/c637819/v637819965/611cd/AJx6PeJg8Y8.jpg)

Вставка узла в начало (push_front)
---

1. выделяется **память** под новый узел
2. **значение** в новом узле устанавливается равным переданному значению
3. **next** в новом узле указывает на элемент, который прежде был первым
4. **previous** в новом узле устанавливается в nullptr
5. **previous** в узле, который был первым, указывает **на новый узел**
6. **head** указывает **на новый элемент**

Вставка узла в начало (схема)
---

![](https://pp.userapi.com/c637819/v637819965/611d5/Sd-K9xMHaOk.jpg)

Вставка узла в конец (push_back)
---

* выделяется **память** под новый узел
* **значение** в новом узле устанавливается равным переданному значению
* **next** в новом узле указывает на **nullptr**
* **previous** в новом узле указывает на элемент, который был последним
* **next** в узле, который был последним, указывает на новый элемент
* **tail** указывает на новый элемент

Вставка узла в конец (схема)
---

![](https://pp.userapi.com/c637819/v637819965/611de/QIfnU89a9nY.jpg)

Удаление узла из начала (pop_front)
---

* **требуется проверка, есть ли узлы в списке и не единственный ли узел нужно удалить**
* **previous** в узле, который следовал за первым, устанавливается в **nullptr**
* **head** указывает на элемент, который следовал за первым
* **освобождается память**, которую занимал первый узел

Удаление узла из начала (схема)
----

![](https://pp.userapi.com/c637819/v637819965/611e6/RVqOV7Tb3S8.jpg)

Удаление узла из конца (pop_back)
---

* **требуется проверка, есть ли узлы в списке и не единственный ли узел нужно удалить**
* **tail** указывает на элемент, который был предпоследним
* **next** в предпоследнем узле устанавливается в **nullptr**
* **освобождается память**, которую занимал последний узел

Удаление узла из конца (схема)
---

![](https://pp.userapi.com/c637819/v637819965/611f5/L7MVcx0gdCw.jpg)

Вставка узла в середину (после существующего узла А)
---

* создается **новый узел**, значение в котором устанавливается равным переданному значению
* находится **узел А**, после которого нужно вставить новый узел
* **previous** в новом узле указывает на узел А
* **next** в новом узле указывает на узел, на который ранее указывал **next** из узла А
* **previous** в узле, следовавшем за А, указывает на новый узел
* **next** в узле А указывает на новый узел

Вставка узла (схема)
---

![](https://pp.userapi.com/c637819/v637819965/611fd/bjIjqPuiuvc.jpg)

Удаление узла из середины (заданного узла A)

* находится узел А, который нужно удалить
* **next** в предыдущем узле начинает указывать на узел за удаляемым узлом
* **previous** в узле за удаляемым узлом А начинает указывать на узел перед А
* **освобождается память**, которую занимал узел A

Удаление узла из середины (схема)
---

![](https://pp.userapi.com/c637819/v637819965/6120b/9ij4uLQlCE0.jpg)

Преимущества и недостатки списков
---

1. `+`
* размер списка не ограничен размером свободного последовательного участка памяти
* эффективное динамическое добавление и удаление элементов

2. `-`
* на поля-указатели расходуется дополнительная память
* осуществляется только последовательный доступ к элементам
* => сложность прямого доступа к элементу

[**-->     Laboratory_work24     <--**](https://github.com/SuvStreet/IT_Step_Cpp/tree/master/Laboratory_work/Work1)

**18.07.2017**
