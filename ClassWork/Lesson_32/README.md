Односвязный список
===

Список
---

Список – структура данных, состоящая из узлов, каждый из которых содержит не только данные, но и одну или две ссылки на следующий и/или предыдущий узел

* односвязный
* двусвязный

Особенности
---

* элементы списка могут храниться не последовательно, а **в разных участках памяти**
* для связи предыдущего элемента со следующим хранится **указатель на следующий элемент**
* списки позволяют эффективно **вставлять** элементы в произвольную позицию списка и **удалять** элементы из произвольной позиции

Основные операции
---

* вставить элемент в список (**insert**)
* удалить элемент из списка (**erase**)
* добавить элемент в конец списка (**push_back**)
* удалить элемент из конца списка (**pop_back**)
* добавить элемент в начало списка (**push_front**)
* удалить элемент из начала списка (**pop_front**)
* узнать количество элементов (**size**)
* проверить на пустоту (**empty**)

Односвязный список
---

* совокупность узлов, состоящих из двух частей: **значения** и **информации о следующем элементе списка**
* только **последовательный доступ к элементам**
* ни один элемент не указывает на голову
* последний элемент указывает на `NULL` (`nullptr`)
* можно передвигаться только **в одну сторону**

![](https://pp.userapi.com/c637819/v637819113/584a8/zxIq5cIfj5Q.jpg)

Реализация: узлы
---

* узел представляет собой **структуру** (обычно вложенную)
* узел содержит **поле с данными и указатель на следующий узел**

```cpp
template <typename T>
struct node {
  T data;
  node* next;
};
```

Объявление класса
---

* создается класс для реализации списка
* в классе дополнительно создаются поля-указатели на голову и хвост списка (**head** и **tail**)

```cpp
template <typename T>
class MyList {
  struct node {
    T data;
    node* next;
  }
  node* head;
  node* tail;
};
```

Инициализация
---

* в начале работы список пуст
* указатели на хвост и на голову ни на что не указывают

```cpp
template <typename T>
MyList <T>::MyList() : head(nullptr), tail(nullptr)
  { }
```

Создание первого узла
---

* динамически выделяется память под узел
* значение в узле устанавливается равным переданному значению
* указатель в узле устанавливается в `nullptr`
* `head` и `tail` указывают на этот новый элемент

![](https://pp.userapi.com/c637819/v637819113/584af/Du3BoGZ8Eko.jpg)

Вставка узла в начало
---

* значение в новом узле устанавливается равным переданному значению
* `next` в новом узле указывает на элемент, который прежде был первым
* `head` указывает на новый элемент

![](https://pp.userapi.com/c637819/v637819113/584b8/CX-c4OyZU0w.jpg)

Вставка узла в конец
---

* значение в новом узле устанавливается равным переданному значению
* `next` в новом узле указывает на `nullptr`
* `next` в элементе, который был последним, указывает на новый элемент
* `tail` указывает на новый элемент

![](https://pp.userapi.com/c637819/v637819113/584d9/bZXnaYs39y4.jpg)

Вставка узла в середину (после существующего узла А)
---

* значение в новом узле устанавливаетсяравным переданному значению
* `next` в новом узле указывает на узел, на который указывал `next` из узла А
* `next` в узле А указывает на новый элемент

![](https://pp.userapi.com/c637819/v637819113/584f1/ZnsGmEtxkeQ.jpg)

Удаление узла из начала
---

* `head` указывает на элемент, который следовал за первым
* освобождается память, которую занимал первый узел

![](https://pp.userapi.com/c637819/v637819113/584fa/Qmw6bRsmsXM.jpg)

Удаление узла из середины (заданного узла A)
---

* указатель в предыдущем узле начинает указывать на узел, на который указывает удаляемый узел А
* освобождается память, которую занимал узел A

![](https://pp.userapi.com/c637819/v637819113/58502/sUFM5CTrUbA.jpg)

Обход списка
---

* обход организуется в цикле (или рекурсивно)
* создается указатель
* начиная с головы, перемещаемся по узлам по полям `next`, пока значение указателя не станет `nullptr`

![](https://pp.userapi.com/c637819/v637819965/6119c/cfprNgF7tmw.jpg)

[**-->     Laboratory_work23     <--**](https://github.com/SuvStreet/IT_Step_Cpp/tree/master/Laboratory_work/Work23)

**17.07.2017**
