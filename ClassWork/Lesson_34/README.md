Бинарное дерево поиска
===

Бинарное (двоичное) дерево поиска
---

* упорядоченная совокупность узлов
* каждый узел имеет **не более двух следующих**
* **нет циклов**

![](https://pp.userapi.com/c637816/v637816820/58169/XxUCmWDZ5F4.jpg)

Строение дерева
---

* **корень** – вершина дерева (всегда один)
* **родительские узлы** (родители)
* **дочерние узлы** (сыновья)
* **листья** – узлы без сыновей

![](https://pp.userapi.com/c637816/v637816820/58171/m8Q3rVUkyi8.jpg)

Строение дерева
---

* **левый сын** – дочерний узел слева
* **правый сын** – дочерний узел справа
* каждый узел является родителем для своих сыновей и сыном для своего родителя

![](https://pp.userapi.com/c637816/v637816820/58179/08IUDizzN14.jpg)

Неравенства дерева
---

* для каждого узла верно, что **значение в его левом сыне меньше, а значение в правом сыне больше (или равно)**, чем в нем самом

![](https://pp.userapi.com/c637816/v637816820/58182/ezAcevzweeA.jpg)

Особенности
--

* значения **всех узлов** левее данного узла **меньше** значения этого узла, а значения **всех узлов правее** данного узла **больше или равны** значению в этом узле
* основное назначение бинарного дерева – **быстрый поиск** элемента с указанным значением
* доступны быстрая вставка и удаление элементов

Деревья и рекурсия
---

* бинарное дерево – рекурсивная структура:
  * пустая структура является бинарным деревом;
  * дерево – это корень и два связанных с ним бинарных дерева, которые называют левым и правым поддеревьями
* используются **рекурсивные алгоритмы**

![](https://pp.userapi.com/c637816/v637816820/5818a/UsqDstby1nQ.jpg)

Основные операции
---

* обойти дерево
* найти элемент (**find**)
* получить минимальный элемент (**min**)
* получить максимальный элемент (**max**)
* вставить элемент в дерево (**insert**)
* удалить элемент из дерева (**erase**)

Реализация: узлы
---

* узел представляет собой **структуру**
* узел содержит **поле с данными** и **указатели**:
  * **на левый дочерний узел**
  * **на правый дочерний узел**
  * **на родительский узел** (этого поля может не быть)

```cpp
template <typename T>
struct node {
  T key;
  node* parent;
  node* left;
  node* right;
};
```

Объявление класса
---

* создается класс для реализации дерева
* в классе дополнительно создается поле-указатель на корень дерева (**root**)

```cpp
template <typename T>
  struct node { ... };

template <typename T>
class BinaryTree{
  node* root;
};
```

Обход дерева
---

* каждая вершина посещается по одному разу, выводится информация из этой вершины
* **используется рекурсия**

1. **прямой** (корень – левое поддерево – правое поддерево)
2. **симметричный** (левое поддерево – корень – правое поддерево)
3. **обратный** (левое поддерево – правое поддерево – корень)

Обход дерева (пример)
---

* создаем указатель `tmp` на переданную вершину
* если указатель не равен `nullptr`, то:
  * если у вершины есть левое поддерево, рекурсивно вызываем функцию обхода для вершины левого поддерева
  * обрабатываем значение в текущей вершине
  * если у вершины есть правое поддерево, рекурсивно вызываем функцию обхода для вершины правого поддерева

Обход дерева (схема)
---

![](https://pp.userapi.com/c637816/v637816820/58192/gTwTV7rUyvU.jpg)

Вставка элемента k
---

1. если дерево пустое, то создать узел и сделать его корнем дерева
2. если в дереве уже есть вершины, то:
  * создать новый узел, проинициализировать его поля; все указатели установить в `nullptr`
  * создать указатель `currentNode` на текущий узел, который сразу будет указывать на корень
3. пока указатель на текущий узел не `nullptr`:
  * если k меньше значения в `currentNode`
    `* если у текущего узла есть левый сын, то перейти в левого сына
    * иначе вставить созданный узел (установить его родителя в текущий узел, указатель на левого сына в текущем узле установить на новый узел)`
  * если k больше или равно значению в currentNode
    `* если у текущего узла есть правый сын, то перейти в правого сына
    * иначе вставить созданный узел (установить его родителя в текущий узел, указатель на правого сына в текущем узле установить на новый узел)`

Вставка элемента (схема)
---

![](https://pp.userapi.com/c637816/v637816820/5819b/7_hGRd1zeSg.jpg)

Поиск минимума
---

* создать указатель на корень дерева
* переходить в левого сына до тех пор, пока указатель на левого сына не `nullptr`

![](https://pp.userapi.com/c637816/v637816820/581a4/T01naBGrIh0.jpg)

Поиск максимума
---

* создать указатель на корень дерева
* переходить в правого сына до тех пор, пока указатель на правого сына не `nullptr`

![](https://pp.userapi.com/c637816/v637816820/581ac/IuT3sYABWWE.jpg)

Поиск элемента (рекурсивный)
---

* сравнить переданное значение `k` со значением в корне дерева
* если значение `k` равно значению в корне, то вернуть корень
* если значение `k` меньше, чем значение в корне, то вызвать функцию поиска для левого поддерева
* если значение `k` больше, чем значение в корне, то вызвать функцию поиска для правого поддерева

Поиск элемента (схема)
---

![](https://pp.userapi.com/c637816/v637816820/581b4/0psnQR2167Y.jpg)

Поиск элемента (нерекурсивный)
---

* создать указатель на текущий узел, проинициализировать его корнем дерева
* пока текущий узел не `nullptr`
  * сравнить переданное значение `k` со значением в текущем узле
  * если значение `k` равно значению в текущем узле, то вернуть текущий узел
  * если значение `k` меньше, чем значение в текущем узле, то перейти в левого сына
  * если значение `k` больше, чем значение в текущем узле, то перейти в правого сына

![](https://pp.userapi.com/c637816/v637816820/581bc/LjrFGjrg0Y4.jpg)

Удаление элемента (1)
---

* найти узел с удаляемым значением
* если у удаляемого узла нет правого поддерева, перенести левое поддерево выше

![](https://pp.userapi.com/c637816/v637816820/581c5/opJgGZ_JbDQ.jpg)

Удаление элемента (2)
---

* найти узел с удаляемым значением
* если у удаляемого узла нет левого поддерева, перенести правое поддерево выше 

![](https://pp.userapi.com/c637816/v637816820/581ce/6wl8aPi5A1g.jpg)

Удаление элемента (3)
---

* найти узел с удаляемым значением
* если у удаляемого узла есть и левый, и правый сын, то найти в правом поддереве минимум и вставить на место удаляемого узла

![](https://pp.userapi.com/c637816/v637816820/581d7/QZ13OxQINKo.jpg)

**19.07.2017**
