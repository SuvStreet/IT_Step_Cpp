Перегрузка операторов
===

Общие сведения
---

1. Перегрузка операторов нужна затем, чтобы сделать вызов функций более удобным (поддержать единый интерфейс).

```cpp
MyArray a;
MyArray b;
MyArray c;

c = a + b;      // объединение двух массивов в одном
if (a != b) {   // проверка на тождественность
  b--;          // удаление последнего элемента
}
```

2. Не следует пользоваться перегрузкой, если выбранный оператор плохо согласуется со смыслом функции.

```cpp
Automobile a;
Automobile b;
Automobile c;

c = a + b;      // ???
if (a != b) {
  b--;          // ???
}
```

Операторы с перегрузкой
---

```
Оператор |   Назначение
---------|----------------------------
  +      |   сложение 
  -      |   вычитание 
  *      |   умножение 
  /      |   деление 
  =      |   присваивание 
  +=     |   присваивание сложения 
  -=     |   присваивание вычитания 
  ==     |   проверка на равенство 
  +      |   унарный плюс
  -      |   унарный минус
  *      |   разыменование указателя
  &      |   взятие адреса
  [ ]    |   обращение по индексу
  ++     |   инкремент
  --     |   декремент
  !      |   логическое не
```

Операторы без перегрузки
---
      
Оператор        |      Назначение
----------------|--------------------------------------------------------
  .             |       обращение к полю или методу объекта
  .*            |       обращение к указателю на поле или метод объекта
  ::            |       разрешение области видимости
  : ?           |       тернарный оператор условия
  sizeof        |       размер в байтах объекта или типа данных
  #             |       директива препроцессора
  ##            |       директива препроцессора

 Основные правила перегрузки
 ---

1. Символ бинарной операции используется для переопределения бинарной операции.
2. Символ унарной операции используется для переопределения унарной операции.

```
+     • два аргумента
++    • один аргумент
=+    • два аргумента
```

3. Перегрузка не меняет приоритет операторов и их ассоциативность.

```cpp
MyClass a;
MyClass b;
MyClass c = a + b * 3;  // (c = (a + (b * 3)))
MyClass d = c = a = b;  // (d = (c = (a = b)))
```

Способы перегрузки
---
      
* метод класса (функция-член)
* дружественная функция
* глобальная функция

Перегрузка методами класса
---

1. В метод неявно передается указатель this.
2. Метод для унарной операции не получает ни одного явного аргумента.
3. Метод для бинарной операции получает один явный аргумент. 

```
унарный   -    • MyClass operator-( );
бинарный  -    • MyClass operator-(const MyClass&);
```

Перегрузка бинарных операторов
---

```cpp
returnType operator op( arg );
  MyClass operator+(const int x);
  bool operator==(const MyClass& obj);
```

* есть один аргумент
* обычно возвращается тип класса или ссылка на тип класса

Арифметические бинарные операторы: пример
---

```cpp
class Digit{
  int x_;
public:
  Digit( ) : x_(0){ }
  explicit Digit(const int x) : x_(x) { }
  ~Digit( ){ }
  Digit operator+(const Digit newDigit) {
  Digit tmp;
  tmp.x_ = x_ + newDigit.x_;
  return tmp;
  }
};
```

Операторы сравнения: пример
---

```cpp
class Digit{
  int x_;
public:
  Digit() : x_(0) { }
  explicit Digit(const int x) : x_(x) { }
  ~Digit( ){ }
  bool operator>(const Digit newDigit){
    return  x_  > newDigit.x_;
  }
};
```

Оператор присваивания
---
      
* должен быть нестатическим методом класса
* не наследуется
* возвращается сам объект (*this)

```cpp
Rectangle& Rectangle::operator=(const Rectangle& rc) {
  if (this == &rc){
    return *this; 
  }
  side1 = rc.side1;
  side2 = rc.side2;
  return *this;
}
```

Оператор копирующего присваивания (=)
---

* если в классе есть конструктор копирования, обязательно нужно перегрузить оператор =

```cpp
MyArray& MyArray ::operator=(const MyArray& obj) {
  if (this == &obj){
  return *this; 
  }
  size = obj.size;
  delete [] arr;
  arr = new double[size];
  for (size_t i = 0; i < size; ++i){ arr[i] = obj.arr[i]; }
  return *this;
}
```

Оператор перемещающего присваивания (=)
---

* если в классе есть конструктор перемещения, обязательно нужно перегрузить оператор =

```cpp
MyArray& MyArray ::operator=(MyArray&& obj) {
  if (this == &obj){
  return *this; 
  }
  size = obj.size;
  delete [] arr;
  arr = obj.arr;
  obj.size = 0;
  obj.arr = nullptr;
  return *this;
}
```

Перегрузка унарных операторов
---

```cpp
returnType operator op( );
    MyClass operator-();
    MyClass operator++();
```

* нет аргументов
* указывается возвращаемый тип

Унарные операторы: пример
---

```cpp
class Digit{
  int x_;
public:
  Digit() : x_(0) { }
  explicit Digit(const int x) : x_(x) { }
  ~Digit( ) { }
  Digit operator-() {
  Digit tmp;
  tmp.x_ = -x_;
  return tmp;
  }
};
```

Инкремент и декремент
---

* префиксная и постфиксная формы реализуются отдельно

```cpp
void f( ){
  Rectangle r(1, 1);
  ++(++(++(++r)));
  
  Rectangle s(1, 1);
  s++;
}
```

Префиксная форма
---
      
* нет аргументов
* возвращается сам объект (*this)

```cpp
Rectangle& Rectangle::operator++( ){
  ++side1;
  ++side2;
  return *this;
  }
  void f( ){
  Rectangle r(1, 1);
  ++(++(++(++r)));
}
```

Постфиксная форма
---
      
* передается один аргумент типа int, который не используется и равен 0
* возвращается временный объект

```cpp
Rectangle Rectangle::operator++(int){
  Rectangle tmp = *this;
  ++side1;
  ++side2; // ++*this;
  return tmp;
}
```

[**-->     Laboratory_work5     <--**](https://github.com/SuvStreet/IT_Step_Cpp/tree/master/Laboratory_work/Work5)

**1.06.2017**
